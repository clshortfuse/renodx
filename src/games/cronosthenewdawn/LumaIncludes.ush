/*
 * Copyright (C) 2025 Filippo Tarpini
 * Luma Framework
 */

#ifndef FLT_MAX
#define FLT_MAX    asfloat(0x7F7FFFFF)
#endif
#ifndef FLT_MIN
#define FLT_MIN    asfloat(0xFF7FFFFF)
#endif

static const float3x3 BT709_TO_AP1_MAT = float3x3(
       0.6130974024, 0.3395231462, 0.0473794514,
       0.0701937225, 0.9163538791, 0.0134523985,
       0.0206155929, 0.1095697729, 0.8698146342);
static const float3x3 AP1_TO_BT709_MAT = float3x3(
       1.7050509927, -0.6217921207, -0.0832588720,
       -0.1302564175, 1.1408047366, -0.0105483191,
       -0.0240033568, -0.1289689761, 1.1529723329);

//RGB linear BT.709/sRGB -> OKLab's LMS
static const float3x3 srgb_to_oklms = {
	0.4122214708f, 0.5363325363f, 0.0514459929f,
	0.2119034982f, 0.6806995451f, 0.1073969566f,
	0.0883024619f, 0.2817188376f, 0.6299787005f};

//OKLab's (_) L'M'S' -> OKLab
static const float3x3 oklms__to_oklab = {
	0.2104542553f,  0.7936177850f, -0.0040720468f,
	1.9779984951f, -2.4285922050f,  0.4505937099f,
	0.0259040371f,  0.7827717662f, -0.8086757660f};

//OKLab -> OKLab's L'M'S' (_)
//the 1s get optimized away by the compiler
static const float3x3 oklab_to_oklms_ = {
	1.f,  0.3963377774f,  0.2158037573f,
	1.f, -0.1055613458f, -0.0638541728f,
	1.f, -0.0894841775f, -1.2914855480f};

//OKLab's LMS -> RGB linear BT.709/sRGB
static const float3x3 oklms_to_srgb = {
	 4.0767416621f, -3.3077115913f,  0.2309699292f,
	-1.2684380046f,  2.6097574011f, -0.3413193965f,
	-0.0041960863f, -0.7034186147f,  1.7076147010f};

// (in) linear sRGB/BT.709
// (out) OKLab
// L - perceived lightness
// a - how green/red the color is
// b - how blue/yellow the color is
float3 linear_srgb_to_oklab(float3 rgb, bool mirrored = true) {
	//LMS
	float3 lms = mul(srgb_to_oklms, rgb);

	//L'M'S'
	// If we pass in scRGB negative colors (or better, colors outside the Oklab gamut), this avoids them breaking
	float3 lms_ = mirrored ? (pow(abs(lms), 1.f/3.f) * sign(lms)) : pow(lms, 1.f/3.f);

	return mul(oklms__to_oklab, lms_);
}

// (in) OKLab
// (out) linear sRGB/BT.709
float3 oklab_to_linear_srgb(float3 lab) {
	//L'M'S'
	float3 lms_ = mul(oklab_to_oklms_, lab);

	//LMS
	float3 lms = lms_ * lms_ * lms_;

	return mul(oklms_to_srgb, lms);
}

static const float3 Rec709_Luminance = float3(0.2126f, 0.7152f, 0.0722f);


float GetLuminance(float3 color)
{

	return dot(color, Rec709_Luminance);
}

// Returns 0, 1, -1/0/+1 or +/-FLT_MAX if "dividend" is 0
float safeDivision(float quotient, float dividend, int fallbackMode = 0)
{
  float result = 0; // We get warning 4000 if just directly return values
	if (dividend == 0)
  {
    if (fallbackMode == 0)
      result = 0;
    else if (fallbackMode == 1)
      result = 1;
    else if (fallbackMode == 2)
      result = sign(quotient); // This will return 0 for 0
    else
      result = FLT_MAX * sign(quotient);
  }
  else
  {
    result = quotient / dividend;
  }
  return result;
}
// Returns 0, 1 or FLT_MAX if "dividend" is 0
float3 safeDivision(float3 quotient, float3 dividend, int fallbackMode = 0)
{
  return float3(safeDivision(quotient.x, dividend.x, fallbackMode), safeDivision(quotient.y, dividend.y, fallbackMode), safeDivision(quotient.z, dividend.z, fallbackMode));
}

// Restores the source color hue (and optionally brightness) through Oklab (this works on colors beyond SDR in brightness and gamut too).
// The strength sweet spot for a strong hue restoration seems to be 0.75, while for chrominance, going up to 1 is ok.
float3 RestoreHueAndChrominance(float3 targetColor, float3 sourceColor, float hueStrength = 0.75, float chrominanceStrength = 1.0, float minChrominanceChange = 0.0, float maxChrominanceChange = FLT_MAX, float lightnessStrength = 0.0)
{
	if (hueStrength == 0.0 && chrominanceStrength == 0.0 && lightnessStrength == 0.0) // Static optimization (useful if the param is const)
		return targetColor;

  // Invalid or black colors fail oklab conversions or ab blending so early out
  if (GetLuminance(targetColor) <= FLT_MIN)
    return targetColor; // Optionally we could blend the target towards the source, or towards black, but there's no need until proven otherwise

	const float3 sourceOklab = linear_srgb_to_oklab(sourceColor);
	float3 targetOklab = linear_srgb_to_oklab(targetColor);
   
  targetOklab.x = lerp(targetOklab.x, sourceOklab.x, lightnessStrength); //TODOFT5: the alt method was used by Bioshock 2, did it make sense? Should it be here?
  
	float currentChrominance = length(targetOklab.yz);

  if (hueStrength != 0.0)
  {
    // First correct both hue and chrominance at the same time (oklab a and b determine both, they are the color xy coordinates basically).
    // As long as we don't restore the hue to a 100% (which should be avoided?), this will always work perfectly even if the source color is pure white (or black, any "hueless" and "chromaless" color).
    // This method also works on white source colors because the center of the oklab ab diagram is a "white hue", thus we'd simply blend towards white (but never flipping beyond it (e.g. from positive to negative coordinates)),
    // and then restore the original chrominance later (white still conserving the original hue direction, so likely spitting out the same color as the original, or one very close to it).
    const float chrominancePre = currentChrominance;
    targetOklab.yz = lerp(targetOklab.yz, sourceOklab.yz, hueStrength);
    const float chrominancePost = length(targetOklab.yz);
    // Then restore chrominance to the original one
    float chrominanceRatio = safeDivision(chrominancePre, chrominancePost, 1);
    targetOklab.yz *= chrominanceRatio;
    //currentChrominance = chrominancePre; // Redundant
  }

  if (chrominanceStrength != 0.0)
  {
    const float sourceChrominance = length(sourceOklab.yz);
    // Scale original chroma vector from 1.0 to ratio of target to new chroma
    // Note that this might either reduce or increase the chroma.
    float targetChrominanceRatio = safeDivision(sourceChrominance, currentChrominance, 1);
    // Optional safe boundaries (0.333x to 2x is a decent range)
    targetChrominanceRatio = clamp(targetChrominanceRatio, minChrominanceChange, maxChrominanceChange);
    targetOklab.yz *= lerp(1.0, targetChrominanceRatio, chrominanceStrength);
  }

	return oklab_to_linear_srgb(targetOklab);
}

// Linear BT.709 in and out. Restore the fog hue and chrominance, to indeed have a look closer to vanilla
float3 FixColorFade(float3 Scene, float3 Fade)
{
  const float FogCorrectionAverageBrightness = 1.0;
  const float FogCorrectionMinBrightness = 0.0;
  const float FogCorrectionHue = 1.0;
  const float FogCorrectionChrominance = 1.0;
  const float FogCorrectionIntensity = 1.0;

  float3 sceneWithFog = Scene + Fade;
  float3 prevSceneWithFog = sceneWithFog.rgb;

  float fadeMax = max(Fade.x, max(Fade.y, Fade.z)); // This might have values below zero but it should be ok
  float3 normalizedFade = fadeMax != 0.0 ? (Fade / fadeMax) : Fade;
  float3 fadeOklab = linear_srgb_to_oklab(normalizedFade);

  float3 sceneOklab = linear_srgb_to_oklab(Scene);
    
  const float fogBrightness = saturate((FogCorrectionAverageBrightness * sceneOklab.x) + FogCorrectionMinBrightness); // Restore an optional min amount of fog on black and a good amount of fog on non black backgrounds
  const float fogHue = FogCorrectionHue * saturate(fadeOklab.z); // Restoring the fog hue might look good if the fog was colorful, but if it was just grey, then it'd randomly shift the background hue to an ugly value, so we scale the fog hue restoration by the chrominance of the fade (it seems like it's usually white/grey in Cronos)
  const float fogChrominance = FogCorrectionChrominance; // Restore the fog chrominance to a 100%, which means we'd either desaturate or saturate the background
  sceneWithFog = RestoreHueAndChrominance(Scene, sceneWithFog, fogHue, fogChrominance, 0.f, FLT_MAX, fogBrightness); 

  return lerp(prevSceneWithFog, sceneWithFog, FogCorrectionIntensity);
}
