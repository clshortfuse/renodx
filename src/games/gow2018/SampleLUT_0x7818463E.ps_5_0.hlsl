//
// Generated by Microsoft (R) HLSL Shader Compiler 10.0.10011.16384
//
//   using 3Dmigoto v1.4.1 on Mon Apr  7 19:26:38 2025
//
//
// Note: shader requires additional functionality:
//       64 UAV slots
//
//
// Buffer Definitions:
//
// cbuffer ConstBuf__passData
// {
//
//   struct PostEffectsFullResPassData
//   {
//
//       struct FullResResolveConstants
//       {
//
//           float MotionBlurEnabled;   // Offset:    0
//           float DebugBlur;           // Offset:    4
//           float DebugBlurEffect;     // Offset:    8
//           float NoOpaquePass;        // Offset:   12
//           uint DebugTakingCalibrationScreenshot;// Offset:   16
//           float DebugMotionVectors;  // Offset:   20
//           float BloomEnabled;        // Offset:   24
//           float2 screenSize;         // Offset:   32
//           float2 screenSizeRcp;      // Offset:   40
//           float2 screenHalfSize;     // Offset:   48
//           float2 screenHalfSizeRcp;  // Offset:   56
//           float2 screenSizeResolved; // Offset:   64
//           float2 screenSizeResolvedRcp;// Offset:   72
//           float2 screenResolvedToUnresolved;// Offset:   80
//           float2 screenUnresolvedToResolved;// Offset:   88
//           float2 motionVectorTemporalRescaleCompress;// Offset:   96
//           float2 motionVectorTemporalRescaleDecompress;// Offset:  104
//           float2 dlssScreenSize;     // Offset:  112
//           float2 screenScale;        // Offset:  120
//           float2 screenOffset;       // Offset:  128
//           float4 scaleOffsetR;       // Offset:  144
//           float4 scaleOffsetG;       // Offset:  160
//           float4 scaleOffsetB;       // Offset:  176
//           float3 Vignette_Color;     // Offset:  192
//           float Vignette_Brightness; // Offset:  204
//           float Vignette_Falloff;    // Offset:  208
//           float Vignette_Scale;      // Offset:  212
//           float lensVignetteExposureSq;// Offset:  216
//           float scale;               // Offset:  220
//           float rcpScreenLensRadius2;// Offset:  224
//           float2 screenLensCenter;   // Offset:  228
//           int filmGrainOffset;       // Offset:  236
//           float4 filmGrainUVTransform;// Offset:  240
//           float filmGrainEffectShadows;// Offset:  256
//           float filmGrainEffectMids; // Offset:  260
//           float filmGrainEffectBrights;// Offset:  264
//           float doUnsharp;           // Offset:  268
//           float unsharpStrength;     // Offset:  272
//           bool DebugNoLUT;           // Offset:  276
//           bool passThrough;          // Offset:  280
//           bool passThrough_Exposure; // Offset:  284
//           bool passThrough_WhiteBalance;// Offset:  288
//           bool passThrough_SLog;     // Offset:  292
//
//       } constants;                   // Offset:    0
//
//       struct ToneMappingConstants
//       {
//
//           float3 WBMatrixR;          // Offset:  304
//           float3 WBMatrixG;          // Offset:  320
//           float3 WBMatrixB;          // Offset:  336
//           float EnableLocalAdaptation;// Offset:  348
//           float Adaptation_Exposure; // Offset:  352
//           float ExposureEV;          // Offset:  356
//           float ExposureEVClampMin;  // Offset:  360
//           float ExposureEVClampMax;  // Offset:  364
//           float LocalAdaptationShadows;// Offset:  368
//           float LocalAdaptationHighlights;// Offset:  372
//           int Tonemapping_Curve;     // Offset:  376
//           float Contrast;            // Offset:  380
//           float HDRMax;              // Offset:  384
//           float HDRWhite;            // Offset:  388
//           float ContrastTimesShoulder;// Offset:  392
//           float ChannelCrossTalk;    // Offset:  396
//           float PrecomputedBMult;    // Offset:  400
//           float PrecomputedCAdd;     // Offset:  404
//           float SceneToScreenPower;  // Offset:  408
//           float IsHDRRendering;      // Offset:  412
//           float DebugHDRRendering;   // Offset:  416
//           float DebugHDRRenderingPhase;// Offset:  420
//           float DebugNoHDRRendering; // Offset:  424
//           float ShowWaveform;        // Offset:  428
//
//       } toneMappingConstants;        // Offset:  304
//
//       struct TemporalAAConsts
//       {
//
//           float TAAConvergenceLimit; // Offset:  432
//           float TAAHP;               // Offset:  436
//           float TAALP;               // Offset:  440
//           float TAAColorExtent;      // Offset:  444
//           float TAACheckerboardFramePhase;// Offset:  448
//           float TAAMotionRejection;  // Offset:  452
//           float TAAEnable;           // Offset:  456
//           float HalfResTAAEnable;    // Offset:  460
//           float HalfResTAAConvergence;// Offset:  464
//           uint TAAForceSmooth;       // Offset:  468
//           float TAATransparentsContributionRejectionMultiply;// Offset:  472
//           float TAAVarianceBlurIncrease;// Offset:  476
//           float TAAVarianceTransparentDecrease;// Offset:  480
//           float TAAEncodeRange;      // Offset:  484
//           float TAAInvEncodeRange;   // Offset:  488
//           uint DebugSimilarity;      // Offset:  492
//           float VarianceWindow;      // Offset:  496
//           float2 UpsampleOffset;     // Offset:  500
//
//       } temporalConsts;              // Offset:  432
//
//       struct DoFCoCStruct
//       {
//
//           float m_Enabled;           // Offset:  512
//           float m_DebugDOF;          // Offset:  516
//           float m_NearDistanceOfAcceptableSharpness;// Offset:  520
//           float m_FarDistanceOfAcceptableSharpness;// Offset:  524
//           float m_CircleOfConfusionMultiplier;// Offset:  528
//           float m_CameraApertureHeightRelativeRcp;// Offset:  532
//           float m_HyperFocalDistance;// Offset:  536
//           float m_FocusDistance;     // Offset:  540
//           float m_FStop;             // Offset:  544
//           float m_DepthReprojectScale;// Offset:  548
//           float m_DepthReprojectBias;// Offset:  552
//
//       } dofConstants;                // Offset:  512
//
//   } resourceTables__passData;        // Offset:    0 Size:   556
// Textures:  t0-t18
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim      HLSL Bind  Count
// ------------------------------ ---------- ------- ----------- -------------- ------
// resourceTables__passData__smpPointClamp    sampler      NA          NA             s0      1
// resourceTables__passData__smpLinearClamp    sampler      NA          NA             s1      1
// resourceTables__passData__smpCompare  sampler_c      NA          NA             s3      1
// resourceTables__passData.LUTTexture    texture  float4          3d             t0      1
// resourceTables__passData.InputLuminanceLocal    texture   float          2d             t1      1
// resourceTables__passData.InputDepth    texture   float          2d             t2      1
// resourceTables__passData.InputColor    texture  float4          2d             t3      1
// resourceTables__passData.InputBloom    texture  float4          2d             t4      1
// resourceTables__passData.InputBlurredSurface    texture  float4          2d             t6      1
// resourceTables__passData.InputTransparents    texture  float4          2d            t12      1
// resourceTables__passData.InputTransparentsLowRes    texture  float4          2d            t13      1
// resourceTables__passData.InputRefraction    texture  float4          2d            t14      1
// resourceTables__passData.NoiseTexture    texture   float     2darray            t17      1
// resourceTables__passData.BilateralVectorsTex    texture  float2          2d            t18      1
// resourceTables__passData.OutRejectionFactor        UAV   float          2d             u9      1
// ConstBuf__passData                cbuffer      NA          NA            cb0      1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xy
// TEXCOORD                 0   xy          1     NONE   float   xy
// TEXCOORD                 1     zw        1     NONE   float
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
//

#include "./common.hlsli"

Texture2D<float4> t18 : register(t18);

Texture2DArray<float4> t17 : register(t17);

Texture2D<float4> t14 : register(t14);

Texture2D<float4> t13 : register(t13);

Texture2D<float4> t12 : register(t12);

Texture2D<float4> t6 : register(t6);

Texture2D<float4> t4 : register(t4);

Texture2D<float4> t3 : register(t3);

Texture2D<float4> t2 : register(t2);

Texture2D<float4> t1 : register(t1);

Texture3D<float4> t0 : register(t0);

SamplerComparisonState s3_s : register(s3);

SamplerState s1_s : register(s1);

SamplerState s0_s : register(s0);

RWTexture2D<float4> resourceTables__passData__OutRejectionFactor : register(u9);  // decompiler missed this

cbuffer cb0 : register(b0) {
  float4 cb0[31];
}

// 3Dmigoto declarations
#define cmp -

void main(
    float4 v0: SV_POSITION0,
    float2 v1: TEXCOORD0,
    float2 w1: TEXCOORD1,
    out float4 o0: SV_Target0) {
  // Needs manual fix for instruction:
  // unknown dcl_: dcl_uav_typed_texture2d (float,float,float,float) u9
  float4 r0, r1, r2, r3, r4, r5;
  uint4 bitmask, uiDest;
  float4 fDest;

  r0.xy = (uint2)v0.xy;
  r0.zw = float2(0, 0);
  r0.zw = t18.Load(r0.xyz).xy;
  r0.zw = cb0[2].zw * r0.zw;
  r1.xyz = t6.SampleLevel(s1_s, v1.xy, 0).xyz;
  r0.zw = r0.zw * float2(8, 8) + v1.xy;
  r1.w = t6.SampleLevel(s1_s, r0.zw, 0).w;
  r2.x = cmp(r1.w < 1);
  if (r2.x != 0) {
    r2.xyz = t14.SampleLevel(s1_s, r0.zw, 0).xyw;
    r3.xy = float2(1, -1) * r2.xy;
    r2.x = dot(r2.xy, r2.xy);
    r2.x = cmp(r2.x != 0.000000);
    if (r2.x != 0) {
      r4.xyzw = t14.Gather(s0_s, v1.xy).xyzw;
      r2.x = min(r4.y, r4.z);
      r2.x = min(r4.x, r2.x);
      r2.x = min(r2.x, r4.w);
      r2.x = max(1, -r2.x);
      r2.x = r2.z / r2.x;
      r4.xy = (int2)r0.xy & int2(63, 63);
      r4.z = 7 & asint(cb0[14].w);
      r4.w = 0;
      r2.y = t17.Load(r4.xyzw).x;
      r2.z = 0.25 * r2.y;
      r3.zw = r3.xy * r2.zz + v1.xy;
      r2.w = t2.SampleCmpLevelZero(s3_s, r3.zw, r2.x).x;
      r4.xyz = r2.yyy * float3(0.25, 0.25, 0.25) + float3(0.25, 0.5, 0.75);
      r5.xyzw = r3.xyxy * r4.xxyy + v1.xyxy;
      r2.y = t2.SampleCmpLevelZero(s3_s, r5.xy, r2.x).x;
      r3.z = t2.SampleCmpLevelZero(s3_s, r5.zw, r2.x).x;
      r5.xy = r3.xy * r4.zz + v1.xy;
      r2.x = t2.SampleCmpLevelZero(s3_s, r5.xy, r2.x).x;
      r2.xyw = cmp(float3(0, 0, 0) >= r2.xyw);
      r2.z = r2.w ? r2.z : 0;
      r2.y = r2.y ? r4.x : r2.z;
      r2.z = cmp(0 >= r3.z);
      r2.y = r2.z ? r4.y : r2.y;
      r2.x = r2.x ? r4.z : r2.y;
    } else {
      r2.x = 0;
    }
    r2.xy = r3.xy * r2.xx + v1.xy;
    r2.xyz = t3.SampleLevel(s1_s, r2.xy, 0).xyz;
    r3.xyzw = t12.SampleLevel(s1_s, v1.xy, 0).xyzw;
    r3.xyzw = max(float4(0, 0, 0, 0), r3.xyzw);
    r4.xyzw = t13.SampleLevel(s1_s, r0.zw, 0).xyzw;
    r4.xyzw = max(float4(0, 0, 0, 0), r4.xyzw);
    r0.z = r4.w * r3.w;
    r3.xyz = r3.xyz * r4.www + r4.xyz;
    r0.w = r3.y + -r2.y;
    r0.w = saturate(cb0[29].z * r0.w);
    r0.z = min(1, r0.z);
    r2.xyz = r2.xyz * r0.zzz + r3.xyz;
    r1.w = saturate(r1.w);
    r0.z = max(r2.y, r2.z);
    r0.z = max(r2.x, r0.z);
    r0.z = 1 + r0.z;
    r0.z = rcp(r0.z);
    r3.xyz = r2.xyz * r0.zzz;
    r2.xyz = -r2.xyz * r0.zzz + r1.xyz;
    r1.xyz = r1.www * r2.xyz + r3.xyz;
  } else {
    r0.w = 0;
  }
  r0.z = max(r1.y, r1.z);
  r0.z = max(r1.x, r0.z);
  r0.z = 1 + -r0.z;
  r0.z = rcp(r0.z);
  r1.xyz = r1.xyz * r0.zzz;
  r0.z = cmp(0 != cb0[21].w);
  if (r0.z != 0) {
    r0.z = t1.SampleLevel(s1_s, v1.xy, 0).x;
    r0.z = exp2(r0.z);
    r2.xyz = r1.xyz * r0.zzz;
  } else {
    r2.xyz = cb0[22].xxx * r1.xyz;
  }
  r1.xyz = t4.SampleLevel(s1_s, v1.xy, 0).xyz;

  r1.rgb *= CUSTOM_BLOOM;

  r1.xyz = cb0[1].zzz * r1.xyz + r2.xyz;
  r2.xy = -cb0[14].yz + v0.xy;
  r0.z = dot(r2.xy, r2.xy);
  r0.z = cb0[14].x * r0.z;
  r0.z = r0.z * r0.z;
  r0.z = cb0[13].z * r0.z;
  r0.z = exp2(-r0.z);
  r1.xyz = r1.xyz * r0.zzz;
  r2.xyz = cb0[20].xyz * r1.yyy;
  r2.xyz = r1.xxx * cb0[19].xyz + r2.xyz;
  r1.xyz = r1.zzz * cb0[21].xyz + r2.xyz;
  r1.xyz = max(float3(0, 0, 0), r1.xyz);
  r2.xyzw = -cb0[12].wxyz + float4(1, 1, 1, 1);
  r0.z = cb0[13].y * v1.x;
  r0.z = v1.y * r0.z;
  r3.xy = float2(1, 1) + -v1.xy;
  r0.z = r3.x * r0.z;
  r0.z = r0.z * r3.y;
  r0.z = log2(abs(r0.z));
  r0.z = cb0[13].x * r0.z;
  r0.z = exp2(r0.z);
  r0.z = saturate(r2.x * r0.z + cb0[12].w);
  r2.xyz = r0.zzz * r2.yzw + cb0[12].xyz;
  r1.xyz = r2.xyz * r1.xyz;
  r0.z = cmp(0 != cb0[0].w);
  r1.xyz = r0.zzz ? float3(0, 0, 0) : r1.xyz;

  // r1.rgb = renodx::color::grade::UserColorGrading(
  //     r1.rgb,
  //     RENODX_TONE_MAP_EXPOSURE,
  //     RENODX_TONE_MAP_HIGHLIGHTS,
  //     RENODX_TONE_MAP_SHADOWS,
  //     RENODX_TONE_MAP_CONTRAST,
  //     1.f,   // saturation, applied later
  //     0.f,   // dechroma, applied later
  //     0.f);  // hue correction, applied later
  // renodx::color::grade::Config cg_config = renodx::color::grade::config::Create();
  // cg_config.exposure = RENODX_TONE_MAP_EXPOSURE;
  // cg_config.highlights = RENODX_TONE_MAP_HIGHLIGHTS;
  // cg_config.shadows = RENODX_TONE_MAP_SHADOWS;
  // cg_config.contrast = RENODX_TONE_MAP_CONTRAST;
  r1.rgb = ApplyExposureContrastFlareHighlightsShadowsByLuminance(r1.rgb);

  float3 lut_input_color = r1.rgb;
#if 0
  // encode arri logc800
  // r2.xyz = cmp(float3(0.0105910003, 0.0105910003, 0.0105910003) < r1.xyz);
  // r3.xyzw = r1.xxyy * float4(5.55555582, 5.3676548, 5.55555582, 5.3676548) + float4(0.0522719994, 0.0928089991, 0.0522719994, 0.0928089991);
  // r1.xy = log2(r3.xz);
  // r1.xy = r1.xy * float2(0.0744116008, 0.0744116008) + float2(0.385536999, 0.385536999);
  // r3.xy = r2.xy ? r1.xy : r3.yw;
  // r1.xy = r1.zz * float2(5.55555582, 5.3676548) + float2(0.0522719994, 0.0928089991);
  // r0.z = log2(r1.x);
  // r0.z = r0.z * 0.0744116008 + 0.385536999;
  // r3.z = r2.z ? r0.z : r1.y;
  r3.rgb = renodx::color::arri::logc::c800::Encode(lut_input_color);

  // sample LUT
  r1.xyz = r3.xyz * float3(0.984375, 0.984375, 0.984375) + float3(0.0078125, 0.0078125, 0.0078125);
  r1.xyz = t0.SampleLevel(s1_s, r1.xyz, 0).xyz;

  // decode arri logc800
  // r2.xyz = cmp(float3(0.149658203, 0.149658203, 0.149658203) < r1.xyz);
  // r3.xyzw = float4(-0.385536999, -0.0928089991, -0.385536999, -0.0928089991) + r1.xxyy;
  // r3.xyzw = float4(13.4387865, 0.186301097, 13.4387865, 0.186301097) * r3.xyzw;
  // r1.xy = exp2(r3.xz);
  // r1.xy = float2(-0.0522719994, -0.0522719994) + r1.xy;
  // r1.xy = float2(0.179999992, 0.179999992) * r1.xy;
  // r3.xy = r2.xy ? r1.xy : r3.yw;
  // r1.xy = float2(-0.385536999, -0.0928089991) + r1.zz;
  // r1.xy = float2(13.4387865, 0.186301097) * r1.xy;
  // r0.z = exp2(r1.x);
  // r0.z = -0.0522719994 + r0.z;
  // r0.z = 0.179999992 * r0.z;
  // r3.z = r2.z ? r0.z : r1.y;
  // r1.xyz = max(float3(0, 0, 0), r3.xyz);
  r1.rgb = renodx::color::arri::logc::c800::Decode(r1.rgb);
#else
  renodx::lut::Config lut_config = renodx::lut::config::Create(
      s1_s,
      1.f,  // lerp after correction
      0.f,  // scaling doesn't work with ARRI
      renodx::lut::config::type::ARRI_C800,
      renodx::lut::config::type::ARRI_C800,
      64.f  // precompute
  );
  lut_config.recolor = 0.f;
  r1.rgb = renodx::lut::Sample(t0, lut_config, lut_input_color);

  if (RENODX_COLOR_GRADE_SCALING) {
    float3 min_black = renodx::color::arri::logc::c800::Decode(t0.SampleLevel(s1_s, renodx::color::arri::logc::c800::Encode((0.f).xxx) + 0.0078125, 0.0f).rgb);

    float lut_min_y = (renodx::color::y::from::BT709(max(0, min_black)));
    if (lut_min_y > 0) {
      float lut_mid_ratio = renodx::color::y::from::BT709(renodx::color::arri::logc::c800::Decode(t0.SampleLevel(s1_s, renodx::color::arri::logc::c800::Encode((0.18f).xxx) + 0.0078125, 0.0f).rgb)) / 0.18f;
      float3 corrected_black = renodx::lut::CorrectBlack(lut_input_color * lut_mid_ratio, r1.rgb, lut_min_y, 70.f);
      r1.rgb = lerp(r1.rgb, corrected_black, RENODX_COLOR_GRADE_SCALING);
    }
  }

#endif
  float3 lut_output_color = max(0, r1.rgb);

  r1.rgb = lerp(lut_input_color, lut_output_color, RENODX_COLOR_GRADE_STRENGTH);

  // additional grading/tonemapping
  r0.z = max(r1.y, r1.z);
  r0.z = max(r1.x, r0.z);
  r2.xyz = cmp(r1.xyz < float3(0.180000007, 0.180000007, 0.180000007));
  r3.xyz = min(cb0[24].xxx, r1.xyz);
  r3.xyz = log2(r3.xyz);
  r4.xyz = cb0[23].www * r3.xyz;
  r4.xyz = exp2(r4.xyz);
  r3.xyz = cb0[24].zzz * r3.xyz;
  r3.xyz = exp2(r3.xyz);
  r3.xyz = r3.xyz * cb0[25].xxx + cb0[25].yyy;
  r3.xyz = r4.xyz / r3.xyz;
  r2.xyz = r2.xyz ? r3.xyz : r1.xyz;
  r2.w = max(r2.y, r2.z);
  r2.w = max(r2.x, r2.w);
  r1.xyz = r2.www * r1.xyz;
  r1.xyz = r1.xyz / r0.zzz;
  r2.xyz = r2.xyz + -r1.xyz;
  r1.xyz = cb0[24].www * r2.xyz + r1.xyz;
  o0.xyz = max(float3(0, 0, 0), r1.xyz);  // output

  r0.z = saturate(r1.w * 4 + -1);
  r0.z = -cb0[29].w * r0.z;
  r1.x = cmp(-0.100000001 < r0.z);
  r0.w = cb0[30].x * r0.w;
  r0.z = r1.x ? r0.w : r0.z;
  r0.z = cb0[29].w + r0.z;
  r0.z = cb0[30].z * r0.z;

  resourceTables__passData__OutRejectionFactor[uint2(r0.xy)] = r0.z;  // store_uav_typed u9.xyzw, r0.xyyy, r0.zzzz
  o0.w = 1;
  return;
}