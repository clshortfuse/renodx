#include "./shared.h"

// ---- Created with 3Dmigoto v1.4.1 on Mon Oct 27 22:32:17 2025

cbuffer _Globals : register(b0)
  // Blend horizon gradients, ocean siege overlays, and finalize tonemapped color.
{
  float4x4 matFroxelViewProj : packoffset(c0);
  float4x4 matFarCloudShadowProjectionTexScale : packoffset(c4);
  float fTextureSampleBias : packoffset(c8) = {0};
  float4 vecTerritoryColor[64] : packoffset(c9);
  float4 vecScaleTranslate : packoffset(c73);
  float4x4 matShadowProjectionTexScale : packoffset(c74);
  float fWaypointMapSectorX : packoffset(c78);
  float fWaypointMapSectorZ : packoffset(c78.y);
  float fWaypointMapSectorSizeX : packoffset(c78.z);
  float fWaypointMapSectorSizeZ : packoffset(c78.w);
  bool isNewSiegeMode : packoffset(c79);
  int arrCycloneSize : packoffset(c79.y) = {0};
  float4 arrCyclone[5] : packoffset(c80);
  float2 shellCountFadeInfo : packoffset(c85);
  bool g_isUseHeight : packoffset(c85.z);
}

cbuffer outdoorScatteringConst : register(b2)
{
  float4 vecSunColorConst : packoffset(c0);
  float4 vecSunGlareColorConst : packoffset(c1);
  float4 vecHorizon0ColorConst : packoffset(c2);
  float4 vecHorizon1ColorConst : packoffset(c3);
  float4 vecSkyBaseColorConst : packoffset(c4);
  float4 vecExtinctionColorConst : packoffset(c5);
  float4 vecReighColorConst : packoffset(c6);
  float4 vecSunScatterColorConst : packoffset(c7);
  float4 vecAmbientColorConst[2] : packoffset(c8);
  float4 vecAmbientOcclusionColorConst : packoffset(c10);
  float4 vecDeepAOColorConst : packoffset(c11);
  float4 vecSkinAmbientColorConst : packoffset(c12);
  float4 vecHairAmbientColorConst : packoffset(c13);
  float4 vecEffectAmbientColorAlphaConst : packoffset(c14);
  float4 vecEffectAmbientColorConst : packoffset(c15);
  float4 vecEffectAmbientColorHit : packoffset(c16);
  float4 vecEffectAmbientColorHitAlpha : packoffset(c17);
  float3 vecSunDirection : packoffset(c18);
  float fSeaHeightConst : packoffset(c18.w);
  float3 vecMoonDirection : packoffset(c19);
  float IndoorRateRegion : packoffset(c19.w);
  float fSunScatterExpConst : packoffset(c20);
  float fSunGlareExpConst : packoffset(c20.y);
  float fSunExpConst : packoffset(c20.z);
  float fScatterDistanceFalloffConst : packoffset(c20.w);
  float fMieDistanceFalloffConst : packoffset(c21);
  float fMieHeightConst : packoffset(c21.y);
  float fReighDistanceFalloffConst : packoffset(c21.z);
  float fEnvIntensityConst : packoffset(c21.w);
  float fHorizonColorExp0Const : packoffset(c22);
  float fHorizonColorExp1Const : packoffset(c22.y);
  float fCharacterLightMultiply : packoffset(c22.z);
  float fCharacterLightMultiply2 : packoffset(c22.w);
  float RainAmount : packoffset(c23);
  float AirTemperature : packoffset(c23.y);
  float AirTemperatureForParticle : packoffset(c23.z);
  float IndoorRateRoof : packoffset(c23.w);
  float3 vecLightDirection : packoffset(c24);
  float fCloudLayer0Const : packoffset(c24.w);
  float fCloudLayer1Const : packoffset(c25);
  float fCloudLayer2Const : packoffset(c25.y);
  float fCloudLayer3Const : packoffset(c25.z);
  float fCloudLayer4Const : packoffset(c25.w);
  float fCloudLayer5Const : packoffset(c26);
  float fCloudLayer6Const : packoffset(c26.y);
  float fCloudLayer7Const : packoffset(c26.z);
  float fCloudLayer8Const : packoffset(c26.w);
  float fCloudLayer9Const : packoffset(c27);
  float fCloudLayer10Const : packoffset(c27.y);
  float fCloudLayer11Const : packoffset(c27.z);
  float fCloudLayer12Const : packoffset(c27.w);
  float4 fShaderTest : packoffset(c28) = {1,1,1,1};
  float4 vecCloudColorConst : packoffset(c29);
  float3 vecColorMultiply : packoffset(c30);
  float fBrightnessMultiply : packoffset(c30.w);
  float fScatteringScale : packoffset(c31);
  float fAerosolDensityScale : packoffset(c31.y);
  float fAerosolPhaseFunG : packoffset(c31.z);
  float fAerosolAbsorbtionScale : packoffset(c31.w);
  float fTurbidity : packoffset(c32);
  float fRayleighHeight : packoffset(c32.y);
  float fMieHeight2 : packoffset(c32.z);
  float fCloudAltitude : packoffset(c32.w);
  float fCloudThickness : packoffset(c33);
  float fCloudDensity : packoffset(c33.y);
  float fCloudDensityContrast : packoffset(c33.z);
  float fCloudBaseScale : packoffset(c33.w);
  float fCloudDetailScale : packoffset(c34);
  bool isSceneScatter : packoffset(c34.y);
  float fRainPoolAmount : packoffset(c34.z);
  float fSnowPoolAmount : packoffset(c34.w);
}

cbuffer HDRConst : register(b3)
{
  float4 MaxEffectOutput : packoffset(c0);
  float MaxEffectColorBrightness : packoffset(c1);
  float hdrEncodeMulti : packoffset(c1.y);
  float hdrEncodeMulti_Effect : packoffset(c1.z);
  float gammaConst : packoffset(c1.w);
}

cbuffer WorldmapCommonConst : register(b4)
{
  float4 vecFarTerrainColorConst : packoffset(c0);
  float4 invScreenSize : packoffset(c1);
  float4 vecWindDirection : packoffset(c2);
  float3 vecCurrentPos : packoffset(c3);
  float totalTime : packoffset(c3.w);
  float3 vecCameraLookAt : packoffset(c4);
  float fBrightnessWorldMap : packoffset(c4.w);
  float3 vecViewPosition : packoffset(c5);
  float fViewDistance : packoffset(c5.w);
  float3 vecLightWorldMap : packoffset(c6);
  float fRenderDeltaTime : packoffset(c6.w);
  bool isCharacterMode : packoffset(c7);
  bool isTownMode : packoffset(c7.y);
  bool isVillageSiege_common : packoffset(c7.z);
  bool doTerrainHide_common : packoffset(c7.w);
  float4 fixedTexCoord_common : packoffset(c8);
  int selectVillageSiegeKey_common : packoffset(c9);
  float fFieldDataResolution_common : packoffset(c9.y);
  float2 dummy_1 : packoffset(c9.z);
}

cbuffer WorldmapTerrainConst : register(b5)
{
  row_major float4x4 matWorldViewProjection : packoffset(c0);
  float4 vecFarTerrainHeightConst : packoffset(c4);
  float4 fixedTexCoord : packoffset(c5);
  float4 StartColorLocationInfo : packoffset(c6);
  float4 EndColorLocationInfo : packoffset(c7);
  float4 MinusColorLocationInfo : packoffset(c8);
  float4 detailTextureInfo : packoffset(c9);
  float fSelectedFieldType : packoffset(c10);
  float fLocationInfoNormalizeMid : packoffset(c10.y);
  float fLocationInfoNormalize : packoffset(c10.z);
  float fFieldDataResolution : packoffset(c10.w);
  bool isLocationInfo : packoffset(c11);
  bool isRegionRender : packoffset(c11.y);
  bool isVillageSiege : packoffset(c11.z);
  bool isOceanSiege : packoffset(c11.w);
  bool doTerrainHide : packoffset(c12);
  bool isGreatSeaMapRender : packoffset(c12.y);
  int selectTerritoryKey : packoffset(c12.z);
  int selectOccupySiegeKey : packoffset(c12.w);
  int selectRegionKey : packoffset(c13);
  int selectOceanSiegeKey : packoffset(c13.y);
  uint territoryDayKey : packoffset(c13.z);
  float dummy : packoffset(c13.w);
}

SamplerState PA_LINEAR_WRAP_FILTER_s : register(s0);
SamplerState PA_LINEAR_BORDER_FILTER_1111_s : register(s1);
SamplerState PA_POINT_WRAP_FILTER_s : register(s2);
SamplerState PA_LINEAR_CLAMP_FILTER_s : register(s3);
Texture2D<float4> texShadowResult : register(t0);
Texture2D<float4> texFarTerrain : register(t1);
Texture2D<float4> texSceneMask : register(t2);
Texture2D<float4> texFarTerrainDetail : register(t3);
Texture2D<float4> texFarTerrainNormal : register(t4);
Texture2D<float4> texTerrainDecalMini : register(t5);
Texture2D<float4> texNoise : register(t6);
Texture2D<float4> texFixedWaterLayer : register(t7);
Texture2D<float4> texTerritoryLayer : register(t8);
Texture2D<float4> texOccupyLayer : register(t9);
Texture2D<float4> texRegionLayer : register(t10);
Texture2D<float4> texOceanRegionLayer : register(t11);
Texture2D<float4> texWaterFlow : register(t12);
Texture2D<float4> texGreatSeaMap : register(t13);
TextureCube<float4> texEnv : register(t14);
Texture2D<float4> texFogTerrainMap : register(t15);


// 3Dmigoto declarations
#define cmp -


void main(
  float4 v0 : SV_POSITION0,
  float4 v1 : TEXCOORD0,
  uint v2 : SV_IsFrontFace0,
  out float4 o0 : SV_TARGET0)
{
  const float4 icb[] = { { 0, 0.925500, 0.925500, 1.000000},
                              { 0, 0.627450, 0.964700, 1.000000},
                              { 0, 0, 0.964700, 1.000000},
                              { 0, 1.000000, 0, 1.000000},
                              { 0, 0.784300, 0, 1.000000},
                              { 0, 0.564700, 0, 1.000000},
                              { 1.000000, 1.000000, 0, 1.000000},
                              { 0.905880, 0.752940, 0, 1.000000},
                              { 1.000000, 0.564700, 0, 1.000000},
                              { 1.000000, 0, 0, 1.000000},
                              { 0.839200, 0, 0, 1.000000},
                              { 0.752940, 0, 0, 1.000000},
                              { 1.000000, 0, 1.000000, 1.000000},
                              { 0.600000, 0.333300, 0.788200, 1.000000} };
  float4 r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16;
  uint4 bitmask, uiDest;
  float4 fDest;

  // Prepare terrain UVs, masks, and normal basis for the far-world map quad.
  r0.xyz = -vecViewPosition.xyz + v1.xyz;
  r0.w = dot(r0.xyz, r0.xyz);
  r0.w = sqrt(r0.w);
  r1.xy = -vecFarTerrainColorConst.xy + v1.xz;
  r1.xy = r1.xy / vecFarTerrainColorConst.zw;
  r1.xy = r1.xy * float2(0.996108949,0.996108949) + float2(0.00194552529,0.00194552529);
  r1.z = 1 + -r1.y;
  r1.yw = texSceneMask.SampleLevel(PA_LINEAR_CLAMP_FILTER_s, r1.xz, 0).xz;
  r2.xy = texFarTerrainNormal.Sample(PA_LINEAR_CLAMP_FILTER_s, r1.xz).zw;
  r2.xz = r2.yx * float2(2,2) + float2(-1,-1);
  r2.w = -r2.x * r2.x + 1;
  r2.y = sqrt(r2.w);
  r2.w = dot(r2.xyz, r2.xyz);
  r2.w = rsqrt(r2.w);
  r3.xyz = r2.xyz * r2.www;
  // Location-info mode swaps the base albedo with pre-authored palette ramps.
  if (isLocationInfo != 0) {
    r4.xy = -vecFarTerrainHeightConst.xy + v1.xz;
    r4.xy = r4.xy / vecFarTerrainHeightConst.zw;
    r3.w = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r4.xy).x;
    r4.x = cmp(r3.w < fLocationInfoNormalizeMid);
    r4.y = fLocationInfoNormalizeMid + -r3.w;
    r4.y = r4.y / fLocationInfoNormalizeMid;
    r3.w = -fLocationInfoNormalizeMid + r3.w;
    r4.z = fLocationInfoNormalize + -fLocationInfoNormalizeMid;
    r3.w = r3.w / r4.z;
    r3.w = r4.x ? r4.y : r3.w;
    r3.w = 5 * r3.w;
    r3.w = trunc(r3.w);
    r3.w = 0.200000003 * r3.w;
    r3.w = min(0.800000012, r3.w);
    r3.w = max(0, r3.w);
    r4.yzw = MinusColorLocationInfo.xyz + -StartColorLocationInfo.xyz;
    r4.yzw = r3.www * r4.yzw + StartColorLocationInfo.xyz;
    r4.yzw = float3(0.5,0.5,0.5) * r4.yzw;
    r5.xyz = EndColorLocationInfo.xyz + -StartColorLocationInfo.xyz;
    r5.xyz = r3.www * r5.xyz + StartColorLocationInfo.xyz;
    r5.xyz = float3(0.5,0.5,0.5) * r5.xyz;
    r4.xyz = r4.xxx ? r4.yzw : r5.xyz;
    r4.w = 0;
  } else {
    // Build the diffuse terrain base from detail textures, decals, and procedural noise.
    r5.xyz = texFarTerrainDetail.Sample(PA_LINEAR_CLAMP_FILTER_s, r1.xz).xyz;
    r6.xyzw = float4(-4.99999987e-05,-4.99999987e-05,-4.99999987e-05,-4.99999987e-05) * v1.zyxy;
    r7.xyz = float3(-0.200000003,-0.200000003,-0.200000003) + abs(r3.xyz);
    r7.xyz = float3(7,7,7) * r7.xyz;
    r7.xyz = max(float3(0,0,0), r7.xyz);
    r1.x = dot(r7.xyz, float3(1,1,1));
    r7.xyz = r7.xyz / r1.xxx;
    r7.xz = detailTextureInfo.ww + r7.xz;
    r1.x = dot(r7.xyz, r7.xyz);
    r1.x = rsqrt(r1.x);
    r1.xz = r7.xz * r1.xx;
    r7.xyz = float3(1.5,1.5,1.5) * r5.xyz;
    r8.xyz = texTerrainDecalMini.Sample(PA_LINEAR_WRAP_FILTER_s, r6.xy).xyz;
    r8.xyz = r8.xyz * r7.xyz + -r5.xyz;
    r5.xyz = r1.xxx * r8.xyz + r5.xyz;
    r6.xyz = texTerrainDecalMini.Sample(PA_LINEAR_WRAP_FILTER_s, r6.zw).xyz;
    r6.xyz = r6.xyz * r7.xyz + -r5.xyz;
    r5.xyz = r1.zzz * r6.xyz + r5.xyz;
    r6.xyz = float3(4.99999987e-06,7.69230792e-06,3.33333332e-06) * r0.www;
    r6.xyz = min(float3(1,1,1), r6.xyz);
    r1.x = -r6.x * r6.x + 1;
    r6.xw = float2(8.33333324e-05,8.33333324e-05) * v1.xz;
    r1.z = texNoise.Sample(PA_LINEAR_WRAP_FILTER_s, r6.xw).y;
    r1.z = r1.z * 2 + -1;
    r5.w = r5.y * 2 + -r5.x;
    r5.w = saturate(r5.w + -r5.z);
    r1.z = r5.w * r1.z;
    r7.xyz = r5.xyz * r1.zzz;
    r5.xyz = r7.xyz * r1.xxx + r5.xyz;
    r5.xyz = r5.xyz * r5.xyz;
    r1.xz = v1.xz * float2(7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zw;
    r7.xyz = float3(0.5,-6400,6400) / fFieldDataResolution;
    r1.xz = r7.xx + r1.xz;
    r1.xz = r1.xz / fixedTexCoord.xy;
  // Decode territory, region, and occupation layers to determine map tinting and highlights.
    r6.x = texOccupyLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r1.xz, 0).w;
    r6.x = 255 * r6.x;
    r6.x = (int)r6.x;
    r6.w = texRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r1.xz, 0).w;
    r6.w = 255 * r6.w;
    r6.w = (int)r6.w;
    r8.x = texTerritoryLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r1.xz, 0).w;
    r8.yz = float2(255,3570) * r8.xx;
    r8.w = (int)r8.y;
    r9.x = cmp((int)r6.x < 64);
    r10.xyz = r9.xxx ? vecTerritoryColor[r6.x].xyz : 0;
    r10.w = r9.x ? 0.650000 : 0;
    r9.xy = cmp(selectRegionKey != int2(255,255));
    r6.x = cmp(selectTerritoryKey == 255);
    r6.x = r6.x ? r9.x : 0;
    r9.x = selectRegionKey + (int)-r6.w;
    r9.x = max((int)r9.x, (int)-r9.x);
    r9.x = (int)r9.x;
    r9.x = cmp(r9.x < 1);
    r9.x = r9.x ? 1.20000005 : 0.600000024;
    r6.x = r6.x ? r9.x : 1;
    r9.x = cmp(selectRegionKey == 255);
    r9.x = r9.y ? r9.x : 0;
    r6.x = r9.x ? 0.600000024 : r6.x;
    r9.x = 3.5 * totalTime;
    r9.x = sin(r9.x);
    r9.x = r9.x * 0.25 + 1.20000005;
    r11.xyzw = float4(-200,0,200,0) + v1.xzxz;
    r11.xyzw = r11.xyzw * float4(7.81249983e-05,7.81249983e-05,7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zwzw;
    r11.xyzw = r11.xyzw + r7.xxxx;
    r11.xyzw = r11.xyzw / fixedTexCoord.xyxy;
    r12.x = texTerritoryLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r11.xy, 0).w;
    r12.y = texTerritoryLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r11.zw, 0).w;
    r13.xyzw = float4(0,-200,0,200) + v1.xzxz;
    r13.xyzw = r13.xyzw * float4(7.81249983e-05,7.81249983e-05,7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zwzw;
    r13.xyzw = r13.xyzw + r7.xxxx;
    r13.xyzw = r13.xyzw / fixedTexCoord.xyxy;
    r12.z = texTerritoryLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r13.xy, 0).w;
    r12.w = texTerritoryLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r13.zw, 0).w;
    r12.xyzw = float4(255,255,255,255) * r12.xyzw;
    r12.xyzw = (int4)r12.xyzw;
    r14.xyzw = cmp((int4)r12.xyzw != (int4)r8.wwww);
    r9.y = (int)r14.y | (int)r14.x;
    r9.y = (int)r14.z | (int)r9.y;
    r9.y = (int)r14.w | (int)r9.y;
    r10.xyzw = r9.yyyy ? float4(1,0.97647059,0.549019635,1) : r10.xyzw;
    r14.x = texRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r11.xy, 0).w;
    r14.y = texRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r11.zw, 0).w;
    r14.z = texRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r13.xy, 0).w;
    r14.w = texRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r13.zw, 0).w;
    r11.xyzw = float4(255,255,255,255) * r14.xyzw;
    r11.xyzw = (int4)r11.xyzw;
    r11.xyzw = cmp((int4)r11.xyzw != (int4)r6.wwww);
    r6.w = (int)r11.y | (int)r11.x;
    r6.w = (int)r11.z | (int)r6.w;
    r6.w = (int)r11.w | (int)r6.w;
    r10.xyzw = r6.wwww ? float4(0.150000006,0.150000006,0.150000006,1) : r10.xyzw;
    r10.xyzw = r9.yyyy ? float4(1,0.97647059,0.549019635,1) : r10.xyzw;
    r6.w = cmp((int)r8.w == 255);
    r11.xyzw = cmp((int4)r12.xyzw != int4(255,255,255,255));
    r9.y = (int)r11.y | (int)r11.x;
    r9.y = (int)r11.z | (int)r9.y;
    r9.y = (int)r11.w | (int)r9.y;
    r11.xyzw = r9.yyyy ? float4(1,0.97647059,0.549019635,1) : float4(0.150000006,0.150000006,0.150000006,0);
    r9.yzw = float3(0,0,0);
    while (true) {
      r12.x = cmp((uint)r9.z >= 8);
      r9.w = 0;
      if (r12.x != 0) break;
      r12.x = (uint)r9.z << 2;
      r12.y = 15 << (int)r12.x;
      r12.y = (int)r12.y & territoryDayKey;
      r12.x = (uint)r12.y >> (uint)r12.x;
      r12.x = cmp((int)r12.x == (int)r8.w);
    // Walk the day/night bitfield to blink the active territory when its identifier matches.
      r9.yw = r12.xx;
      r12.y = r12.x;
      if (r12.y != 0) break;
      r9.z = (int)r9.z + 1;
      r9.w = r12.x;
      r9.y = 0;
    }
    r8.w = (int)r9.y & (int)r9.w;
    r9.x = r10.w * r9.x;
    r10.w = r8.w ? r9.x : r10.w;
    r9.xyzw = r6.wwww ? r11.xyzw : r10.xyzw;
    r6.w = r9.w * r6.x;
    r9.xyz = r9.xyz * r6.xxx + -r5.xyz;
    r9.xyz = r6.www * r9.xyz + r5.xyz;
    r9.xyz = float3(0.25,0.25,0.25) * r9.xyz;
    r6.x = texTerritoryLayer.SampleLevel(PA_LINEAR_WRAP_FILTER_s, r1.xz, 0).w;
    r6.w = selectTerritoryKey;
    r6.w = -r8.x * 255 + r6.w;
    r8.w = cmp(abs(r6.w) < 0.400000006);
    r10.xy = -vecCurrentPos.xz + v1.xz;
    r9.w = dot(r10.xy, r10.xy);
    r9.w = sqrt(r9.w);
    r9.w = r9.w * 4.99999987e-05 + -totalTime;
    r9.w = sin(r9.w);
    r9.w = 1 + r9.w;
    r10.x = 0.5 * r9.w;
    r9.w = r10.x * r10.x;
    r11.xyz = r9.www * float3(0.899999976,0.899999976,-0.100000001) + float3(0,0,1);
    r10.yzw = r11.xyz * r10.xxx;
    r8.z = cmp(r8.z >= -r8.z);
    r11.xy = r8.zz ? float2(14,0.0714285746) : float2(-14,-0.0714285746);
    r8.z = r11.y * r8.y;
    r8.z = frac(r8.z);
    r8.z = r11.x * r8.z;
    r8.z = (uint)r8.z;
    r11.x = 0;
    r11.yzw = icb[r8.z+0].xyz;
    r10.xyzw = r8.wwww ? r10.xyzw : r11.xyzw;
    r6.x = r6.x * 255 + -r8.y;
    r6.x = cmp(0.0500000007 < abs(r6.x));
    r6.x = r8.w ? r6.x : 0;
    r11.xyz = float3(-0,-0,-1) + r10.yzw;
    r11.w = 0;
    r11.xyzw = r10.xxxx * r11.xyzw + float4(0,0,1,1);
    r8.x = cmp(r8.x >= 1);
    r8.y = cmp(0.699999988 < icb[r8.z+0].x);
    r12.xy = cmp(icb[r8.z+0].yz < float2(0.300000012,0.300000012));
    r8.y = r8.y ? r12.x : 0;
    r8.y = r12.y ? r8.y : 0;
    r12.xyz = icb[r8.z+0].xyz;
    r12.w = 0.0500000007;
    r12.xyzw = r8.yyyy ? float4(0,0,1,0.0500000007) : r12.xyzw;
    r12.xyzw = r8.wwww ? float4(0,0,1,0.400000006) : r12.xyzw;
    r12.xyzw = r8.xxxx ? float4(0,0,0,1) : r12.xyzw;
    r13.xyz = r10.yzw;
    r13.w = 0.300000012;
    r14.xyzw = r13.xyzw + -r12.xyzw;
    r12.xyzw = r10.xxxx * r14.xyzw + r12.xyzw;
    r8.x = 1 + r6.y;
    r8.yz = float2(400,400) + v1.xz;
    r14.xyzw = float4(6400,6400,0.00124999997,0.00124999997) * r8.yzyz;
    r15.xyzw = cmp(r14.xxyy >= -r14.xxyy);
    r15.xyzw = r15.xyzw ? float4(6400,0.000156249997,6400,0.000156249997) : float4(-6400,-0.000156249997,-6400,-0.000156249997);
    r8.yz = r15.yw * r8.yz;
    r8.yz = frac(r8.yz);
    r10.yz = r15.xz * r8.yz;
    r14.xy = cmp(r10.yz < float2(0,0));
    r8.yz = r15.xz * r8.yz + float2(6400,6400);
    r8.yz = r14.xy ? r8.yz : r10.yz;
    r10.yz = float2(120,50) * r8.xx;
    r10.yw = cmp(r8.yz < r10.yy);
    r8.x = (int)r10.w | (int)r10.y;
    r9.w = 0.800000012 * r6.y;
    r6.yz = float2(1,1) + -r6.zy;
    r15.xyzw = r9.wwww * r6.yyyy + r12.xyzw;
    r16.xyzw = float4(800,800,800,800) * r8.yyzz;
    r16.xyzw = cmp(r16.xyzw >= -r16.yyww);
    r16.xyzw = r16.xyzw ? float4(800,0.00124999997,800,0.00124999997) : float4(-800,-0.00124999997,-800,-0.00124999997);
    r8.yz = r16.yw * r8.yz;
    r8.yz = frac(r8.yz);
    r8.yz = r16.xz * r8.yz;
    r8.yz = cmp(r8.yz < r10.zz);
    r6.y = (int)r8.z | (int)r8.y;
    r16.xyzw = r6.zzzz * float4(0.400000006,0.400000006,0.400000006,0.400000006) + r12.xyzw;
    r8.yz = floor(r14.zw);
    r6.z = r8.y + r8.z;
    r8.y = r6.z + r6.z;
    r8.y = cmp(r8.y >= -r8.y);
    r8.yz = r8.yy ? float2(2,0.5) : float2(-2,-0.5);
    r6.z = r8.z * r6.z;
    r6.z = frac(r6.z);
    r6.z = r8.y * r6.z;
    r6.z = cmp(0.000000 == r6.z);
    r12.xyz = r8.www ? float3(0,0,1) : r12.xyz;
    r12.xyzw = r6.zzzz ? float4(0.300000012,0.300000012,0.300000012,0.300000012) : r12.xyzw;
    r13.xyzw = r13.xyzw + -r12.xyzw;
    r10.xyzw = r10.xxxx * r13.xyzw + r12.xyzw;
    r12.w = 0;
    r10.xyzw = r8.wwww ? r10.xyzw : r12.xyzw;
    r10.xyzw = r6.yyyy ? r16.xyzw : r10.xyzw;
    r8.xyzw = r8.xxxx ? r15.xyzw : r10.xyzw;
    r8.xyzw = r6.xxxx ? r11.xyzw : r8.xyzw;
    r6.x = 1 + -r8.w;
  // Combine overlay alpha with the procedural terrain base.
    r8.xyz = r8.xyz * r8.www;
    r6.xyz = r5.xyz * r6.xxx + r8.xyz;
    r6.w = cmp(abs(r6.w) >= 0.400000006);
    r8.xyz = r6.xyz * r6.xyz;
    r6.xyz = r6.www ? r8.xyz : r6.xyz;
    r6.xyz = isNewSiegeMode ? r9.xyz : r6.xyz;
    r8.x = texTerritoryLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r1.xz).w;
    r8.y = cmp(0.000000 == r8.x);
    r9.xyzw = cmp(r8.xxxx < float4(0.00431372551,0.00823529437,0.0121568628,0.0160784312));
    r10.xyzw = cmp(r8.xxxx < float4(0.0199999996,0.0239215679,0.0278431363,0.0317647047));
    r8.xzw = cmp(r8.xxx < float3(0.0356862731,0.0396078415,0.0435294099));
    r11.xyzw = r8.wwww ? float4(0.90196079,0.392156869,0.156862751,0.509803951) : float4(0,0,0,1);
    r11.xyzw = r8.zzzz ? float4(0.172549024,0.349019617,0.827450991,0.509803951) : r11.xyzw;
    r11.xyzw = r8.xxxx ? float4(0.435294122,0.435294122,0.435294122,0.509803951) : r11.xyzw;
    r11.xyzw = r10.wwww ? float4(0.549019635,0.349019617,0.435294122,0.509803951) : r11.xyzw;
    r11.xyzw = r10.zzzz ? float4(0.0549019612,0.149019614,0.619607866,0.509803951) : r11.xyzw;
    r11.xyzw = r10.yyyy ? float4(0.450980395,0.219607845,0.129411772,0.509803951) : r11.xyzw;
    r10.xyzw = r10.xxxx ? float4(0.403921574,0.156862751,0.431372553,0.470588237) : r11.xyzw;
    r10.xyzw = r9.wwww ? float4(0.490196079,0.36470589,0.0941176489,0.470588237) : r10.xyzw;
    r10.xyzw = r9.zzzz ? float4(0.411764711,0.0274509806,0.0392156877,0.509803951) : r10.xyzw;
    r10.xyzw = r9.yyyy ? float4(0.0352941193,0.443137258,0.0705882385,0.392156869) : r10.xyzw;
    r9.xyzw = r9.xxxx ? float4(0.450980395,0.482352942,0.0745098069,0.352941185) : r10.xyzw;
    r8.xyzw = r8.yyyy ? float4(0.0117647061,0.278431386,0.443137258,0.392156869) : r9.xyzw;
    r1.x = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r1.xz).w;
  // Gather the local min/max water level to fade between dry terrain and flooded tiles.
    r1.z = 255 * r1.x;
    r9.xyzw = v1.xzxz + r7.yyyz;
    r9.xyzw = r9.xyzw * float4(7.81249983e-05,7.81249983e-05,7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zwzw;
    r9.xyzw = r9.xyzw + r7.xxxx;
    r9.xyzw = r9.xyzw / fixedTexCoord.xyxy;
    r9.x = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r9.xy).w;
    r9.x = 255 * r9.x;
    r9.y = min(r9.x, r1.z);
    r9.x = max(r9.x, r1.z);
    r7.w = 0;
    r10.xyzw = v1.xzxz + r7.ywwy;
    r10.xyzw = r10.xyzw * float4(7.81249983e-05,7.81249983e-05,7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zwzw;
    r10.xyzw = r10.xyzw + r7.xxxx;
    r10.xyzw = r10.xyzw / fixedTexCoord.xyxy;
    r10.x = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r10.xy).w;
    r10.x = 255 * r10.x;
    r9.y = min(r10.x, r9.y);
    r9.x = max(r10.x, r9.x);
    r9.z = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r9.zw).w;
    r9.z = 255 * r9.z;
    r9.y = min(r9.y, r9.z);
    r9.x = max(r9.x, r9.z);
    r9.z = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r10.zw).w;
    r9.z = 255 * r9.z;
    r9.y = min(r9.y, r9.z);
    r9.x = max(r9.x, r9.z);
    r9.y = min(r9.y, r1.z);
    r9.x = max(r9.x, r1.z);
    r10.xyzw = v1.xzxz + r7.wzzw;
    r10.xyzw = r10.xyzw * float4(7.81249983e-05,7.81249983e-05,7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zwzw;
    r10.xyzw = r10.xyzw + r7.xxxx;
    r10.xyzw = r10.xyzw / fixedTexCoord.xyxy;
    r7.w = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r10.xy).w;
    r7.w = 255 * r7.w;
    r9.y = min(r9.y, r7.w);
    r7.w = max(r9.x, r7.w);
    r11.xyzw = v1.xzxz + r7.zyzz;
    r11.xyzw = r11.xyzw * float4(7.81249983e-05,7.81249983e-05,7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zwzw;
    r11.xyzw = r11.xyzw + r7.xxxx;
    r11.xyzw = r11.xyzw / fixedTexCoord.xyxy;
    r7.x = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r11.xy).w;
    r7.x = 255 * r7.x;
    r7.y = min(r9.y, r7.x);
    r7.x = max(r7.w, r7.x);
    r7.z = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r10.zw).w;
    r7.z = 255 * r7.z;
    r7.y = min(r7.y, r7.z);
    r7.x = max(r7.x, r7.z);
    r7.z = texFixedWaterLayer.Sample(PA_LINEAR_WRAP_FILTER_s, r11.zw).w;
    r7.z = 255 * r7.z;
    r7.y = min(r7.y, r7.z);
    r7.x = max(r7.x, r7.z);
    r7.z = r7.x + -r7.y;
    r7.w = cmp(r7.z == 0.000000);
    r1.x = r1.x * 255 + -r7.y;
    r1.x = r1.x / r7.z;
    r1.x = r7.w ? 0.5 : r1.x;
    r9.x = floor(r1.x);
    r1.x = -r9.x + r1.x;
    r1.x = -0.5 + r1.x;
    r9.x = 1 + -r8.w;
    r8.xyz = r8.xyz * r8.www;
    r8.xyz = r5.xyz * r9.xxx + r8.xyz;
    r8.w = cmp(-0.300000012 < r1.x);
    r9.x = cmp(r1.x < 0);
    r8.w = r8.w ? r9.x : 0;
    r9.xyz = r8.xyz + abs(r1.xxx);
    r1.x = cmp(0 < fSelectedFieldType);
    r7.xy = -fSelectedFieldType + r7.xy;
    r7.xy = cmp(abs(r7.xy) < float2(0.5,0.5));
    r7.x = (int)r7.x | (int)r7.y;
    r1.x = r1.x ? r7.x : 0;
    r1.z = floor(r1.z);
    r1.z = fSelectedFieldType + -r1.z;
    r7.x = totalTime + totalTime;
    r7.x = sin(r7.x);
    r7.xy = r7.xx * float2(0.200000003,0.200000003) + float2(0.600000024,0.5);
    r10.xyz = r7.xxx * float3(0.300000012,0.300000012,0.300000012) + r8.xyz;
    r1.z = abs(r1.z) / r7.z;
    r7.x = cmp(r1.z < 0.5);
    r1.z = 1 + -r1.z;
    r1.z = 0.300000012 * r1.z;
    r11.xyz = r1.zzz * r7.yyy + r8.xyz;
    r7.xyz = r7.xxx ? r11.xyz : r8.xyz;
    r7.xyz = r7.www ? r10.xyz : r7.xyz;
    r7.xyz = r1.xxx ? r7.xyz : r8.xyz;
    r7.xyz = r8.www ? r9.xyz : r7.xyz;
    r1.xz = -vecFarTerrainHeightConst.xy + v1.xz;
    r1.xz = r1.xz / vecFarTerrainHeightConst.zw;
    r1.x = texGreatSeaMap.Sample(PA_POINT_WRAP_FILTER_s, r1.xz).w;
    r3.w = 255 * r1.x;
    r1.xz = float2(0.00999999978,0.00999999978) * v1.xz;
    r8.xy = floor(r1.xz);
    r1.xz = ceil(r1.xz);
    r9.xyw = sin(r8.xyy);
    r8.y = dot(r9.xy, float2(12.9890003,78.2330017));
    r8.y = sin(r8.y);
    r8.y = 143758.547 * r8.y;
    r10.x = frac(r8.y);
    r8.y = dot(r9.xy, float2(39.3460007,11.1350002));
    r8.y = sin(r8.y);
    r8.y = 143758.547 * r8.y;
    r10.y = frac(r8.y);
    r8.yz = r10.xy * float2(2,2) + float2(-1,-1);
    r9.z = sin(r1.x);
    r8.w = dot(r9.zw, float2(12.9890003,78.2330017));
    r8.w = sin(r8.w);
    r8.w = 143758.547 * r8.w;
    r9.x = frac(r8.w);
    r8.w = dot(r9.zw, float2(39.3460007,11.1350002));
    r8.w = sin(r8.w);
    r8.w = 143758.547 * r8.w;
    r9.y = frac(r8.w);
    r9.xy = r9.xy * float2(2,2) + float2(-1,-1);
    r10.x = sin(r8.x);
    r10.yzw = sin(r1.zxz);
    r1.x = dot(r10.xy, float2(12.9890003,78.2330017));
    r1.x = sin(r1.x);
    r1.x = 143758.547 * r1.x;
    r11.x = frac(r1.x);
    r1.x = dot(r10.xy, float2(39.3460007,11.1350002));
    r1.x = sin(r1.x);
    r1.x = 143758.547 * r1.x;
    r11.y = frac(r1.x);
    r1.xz = r11.xy * float2(2,2) + float2(-1,-1);
    r8.x = dot(r10.zw, float2(12.9890003,78.2330017));
    r8.x = sin(r8.x);
    r8.x = 143758.547 * r8.x;
    r10.x = frac(r8.x);
    r8.x = dot(r10.zw, float2(39.3460007,11.1350002));
    r8.x = sin(r8.x);
    r8.x = 143758.547 * r8.x;
    r10.y = frac(r8.x);
    r8.xw = r10.xy * float2(2,2) + float2(-1,-1);
    r9.zw = frac(v1.xz);
    r8.y = dot(r8.yz, r9.zw);
    r10.xyzw = float4(-0,-1,-1,-0) + r9.zwzw;
    r8.z = dot(r9.xy, r10.xy);
    r1.x = dot(r1.xz, r10.zw);
    r9.xy = float2(-1,-1) + r9.zw;
    r1.z = dot(r8.xw, r9.xy);
    r8.xw = r9.zw * r9.zw;
    r9.xy = float2(1,1) + -r9.zw;
    r9.xy = -r9.xy * r9.xy + float2(1,1);
    r9.xy = -r9.zw * r9.zw + r9.xy;
    r8.xw = r9.zw * r9.xy + r8.xw;
    r8.z = r8.z + -r8.y;
    r8.y = r8.x * r8.z + r8.y;
    r1.z = r1.z + -r1.x;
    r1.x = r8.x * r1.z + r1.x;
    r1.x = r1.x + -r8.y;
    r1.x = r8.w * r1.x + r8.y;
    r1.x = 0.5 + r1.x;
    r1.x = 6 * r1.x;
    r5.w = frac(r1.x);
    r8.xyz = r5.xyz * r5.xyz;
    r8.xyz = float3(0.300000012,0.300000012,0.300000012) * r8.xyz;
    r8.xyz = doTerrainHide ? r8.xyz : r5.xyz;
    r8.w = 0;
    r5.xyzw = isGreatSeaMapRender ? r5.xyzw : r8.xyzw;
    r7.w = 0;
    r5.xyzw = isRegionRender ? r7.xyzw : r5.xyzw;
    r6.w = 0;
    r4.xyzw = isVillageSiege ? r6.xyzw : r5.xyzw;
  }
  // Compute distance fog, shadow min-max, and apply directional + ambient lighting.
  r1.xz = -vecFarTerrainHeightConst.xy + v1.xz;
  r1.xz = r1.xz / vecFarTerrainHeightConst.zw;
  r5.x = texFogTerrainMap.SampleLevel(PA_LINEAR_CLAMP_FILTER_s, r1.xz, 0).w;
  r5.x = 16 * r5.x;
  r5.x = r5.x * r5.x;
  r5.x = min(1, r5.x);
  r5.yz = -vecCurrentPos.xz + v1.xz;
  r5.y = dot(r5.yz, r5.yz);
  r5.y = sqrt(r5.y);
  r5.z = -r5.y * 6.66666674e-05 + 1;
  r5.z = max(0, r5.z);
  r5.z = r5.z * 0.5 + r5.x;
  r5.z = min(1, r5.z);
  r5.x = isCharacterMode ? r5.z : r5.x;
  r4.xyz = r4.xyz + r4.xyz;
  r5.zw = v0.xy * invScreenSize.xy + invScreenSize.zw;
  r6.xyz = texShadowResult.Sample(PA_LINEAR_BORDER_FILTER_1111_s, r5.zw).xyz;
  r5.z = min(r6.x, r6.y);
  r4.xyz = log2(r4.xyz);
  r4.xyz = float3(0.800000012,0.800000012,0.800000012) * r4.xyz;
  r4.xyz = exp2(r4.xyz);
  r4.xyz = float3(0.800000012,0.800000012,0.800000012) * r4.xyz;
  r3.x = dot(r3.xyz, vecLightWorldMap.xyz);
  r3.x = saturate(r3.x * 0.5 + 0.5);
  r3.y = saturate(0.300000012 + r5.z);
  r3.x = r3.x * r3.y;
  r6.xyw = rsqrt(vecSunColorConst.xyz);
  r6.xyw = float3(1,1,1) / r6.xyw;
  r7.xyz = float3(0.5,0.5,0.5) * vecAmbientOcclusionColorConst.xyz;
  r3.xyz = r3.xxx * r6.xyw + r7.xyz;
  r5.w = 1 + -vecLightWorldMap.y;
  r5.w = r5.w * r5.w;
  r7.xyz = r5.www * r3.xyz;
  r3.xyz = r7.xyz * float3(2,2,2) + r3.xyz;
  r3.xyz = r4.xyz * r3.xyz;
  r3.xyz = fBrightnessWorldMap * r3.xyz;
  r3.xyz = RENODX_WORLD_MAP_EXPOSURE * r3.xyz;
  r3.xyz = float3(4,4,4) * r3.xyz;
  r4.x = 1 + -r6.z;
  r4.yz = cmp(float2(0,0) < r1.yw);
  r5.w = cmp(isTownMode != 0);
  r5.w = cmp((int)r5.w == 0);
  r4.y = r4.y ? r5.w : 0;
  r5.w = cmp(isVillageSiege != 0);
  r5.w = cmp((int)r5.w == -1);
  r6.z = cmp(isNewSiegeMode != 0);
  r6.z = cmp((int)r6.z == 0);
  r5.w = r5.w ? r6.z : 0;
  r4.y = r4.y ? r5.w : 0;
  if (r4.y != 0) {
    r1.y = cmp(0.300000012 < r1.y);
    r1.y = r1.y ? 1.000000 : 0;
    r4.y = r5.y * 9.99999975e-06 + -totalTime;
    r4.y = sin(r4.y);
    r4.y = 1 + -abs(r4.y);
    r1.y = r4.y * r1.y;
    r1.y = log2(r1.y);
    r1.y = 14 * r1.y;
    r1.y = exp2(r1.y);
    r3.xyz = r1.yyy * r3.xyz + r3.xyz;
  }
  // Sample animated flow noise to drive water foam and river shimmer.
  r5.yw = float2(0.00300000003,0.00300000003) * v1.xz;
  r7.xy = v1.xz * float2(7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zw;
  r1.y = 0.5 / fFieldDataResolution;
  r7.xy = r7.xy + r1.yy;
  r7.xy = r7.xy / fixedTexCoord.xy;
  r7.z = 1 + -r7.y;
  r7.zw = texWaterFlow.Sample(PA_LINEAR_CLAMP_FILTER_s, r7.xz).yw;
  r4.y = 6.28318024 * r7.z;
  sincos(r4.y, r8.x, r9.x);
  r4.y = texNoise.Sample(PA_LINEAR_WRAP_FILTER_s, r5.yw).y;
  r5.y = 0.0500000007 * totalTime;
  r4.y = r4.y * 0.200000003 + r5.y;
  r5.y = 0.5 + r4.y;
  r4.y = frac(r4.y);
  r5.y = frac(r5.y);
  r8.y = r9.x;
  r8.zw = r8.xy * r4.yy;
  r5.yw = r8.xy * r5.yy;
  r9.xy = float2(3.50000009e-05,3.50000009e-05) * v1.xz;
  r9.xy = texNoise.Sample(PA_LINEAR_WRAP_FILTER_s, r9.xy).xy;
  r9.zw = v1.xz * float2(0.000119999997,0.000119999997) + r8.zw;
  r9.zw = texNoise.Sample(PA_LINEAR_WRAP_FILTER_s, r9.zw).xy;
  r8.zw = v1.xz * float2(0.000123000005,0.000123000005) + r8.zw;
  r8.zw = texNoise.Sample(PA_LINEAR_WRAP_FILTER_s, r8.zw).xy;
  r10.xy = v1.xz * float2(0.000119999997,0.000119999997) + r5.yw;
  r10.xy = texNoise.Sample(PA_LINEAR_WRAP_FILTER_s, r10.xy).xy;
  r5.yw = v1.xz * float2(0.000123000005,0.000123000005) + r5.yw;
  r5.yw = texNoise.Sample(PA_LINEAR_WRAP_FILTER_s, r5.yw).xy;
  r6.z = cmp(0 < r4.x);
  r4.z = (int)r4.z | (int)r6.z;
  if (r4.z != 0) {
    // When water coverage is present, synthesize normals and sample the environment for reflections.
    r0.xyz = r0.xyz / r0.www;
    r4.y = -0.5 + r4.y;
    r4.y = abs(r4.y) + abs(r4.y);
    r9.xy = float2(-0.5,-0.5) + r9.xy;
    r8.zw = r9.zw + r8.zw;
    r5.yw = r10.xy + r5.yw;
    r5.yw = r5.yw + -r8.zw;
    r4.yz = r4.yy * r5.yw + r8.zw;
    r4.yz = r9.xy * float2(0.5,0.5) + r4.yz;
    r9.xz = float2(-1,-1) + r4.yz;
    r4.y = dot(r8.xy, r8.xy);
    r4.y = sqrt(r4.y);
    r9.y = r4.y * -4.25 + 5;
    r4.y = dot(r9.xyz, r9.xyz);
    r4.y = rsqrt(r4.y);
    r8.xyz = r9.xyz * r4.yyy;
    r4.y = saturate(r4.x + -r1.w);
    r4.y = 1.5 * r4.y;
    r2.xyz = r2.xyz * r2.www + -r8.xyz;
    r2.xyz = r4.yyy * r2.xyz + r8.xyz;
    r2.w = dot(-r2.xyz, r0.xyz);
    r2.w = r2.w + r2.w;
    r0.xyz = r0.xyz * -r2.www + -r2.xyz;
    r2.x = 3.33333332e-06 * r0.w;
    r2.x = min(1, r2.x);
    r2.x = 1 + -r2.x;
    r2.x = log2(r2.x);
    r2.x = 1.5 * r2.x;
    r2.x = exp2(r2.x);
    r2.y = max(0.100000001, r7.w);
    r0.xyz = texEnv.SampleLevel(PA_LINEAR_CLAMP_FILTER_s, r0.xyz, 0).xyz;
    r0.xyz = float3(0.5,0.5,0.5) * r0.xyz;
    r0.xyz = r2.yyy * float3(0.0435917154,0.270526469,0.389763653) + r0.xyz;
    r2.yzw = r0.xyz * r6.xyw;
    r2.yzw = float3(0.5,0.5,0.5) * r2.yzw;
    r0.xyz = r0.xyz * float3(0.5,0.5,0.5) + r2.yzw;
    r2.xyz = r0.xyz * r2.xxx;
    r2.xyz = float3(0.600000024,0.600000024,0.600000024) * r2.xyz;
    r0.xyz = r0.xyz * float3(0.400000006,0.400000006,0.400000006) + r2.xyz;
    r0.xyz = r0.xyz + r0.xyz;
    r2.x = saturate(0.699999988 + r5.z);
    r2.y = saturate(r4.x * 0.25 + r1.w);
    r0.xyz = r0.xyz * r2.xxx + -r3.xyz;
    r0.xyz = r2.yyy * r0.xyz + r3.xyz;
    r2.x = saturate(1.75 + -r4.x);
    r2.yzw = r2.xxx * r0.xyz;
    r3.w = (int)r3.w;
    r4.x = (int)r3.w ^ 9;
    r4.y = max((int)-r3.w, (int)r3.w);
    uiDest.x = (uint)r4.y / 9;
    r8.x = (uint)r4.y % 9;
    r6.x = uiDest.x;
    r4.y = -(int)r6.x;
    r4.x = (int)r4.x & 0x80000000;
    r4.x = r4.x ? r4.y : r6.x;
    r4.x = (int)r4.x + 1;
    r3.w = (int)r3.w & 0x80000000;
    r4.y = -(int)r8.x;
    r3.w = r3.w ? r4.y : r8.x;
    r6.xyzw = cmp(int4(1,2,3,4) == (int4)r3.wwww);
    r8.xyzw = cmp(int4(5,6,7,8) == (int4)r3.wwww);
    r4.yz = r8.ww ? float2(-1,1) : 0;
    r4.yz = r8.zz ? float2(-1,0) : r4.yz;
    r4.yz = r8.yy ? float2(-1,-1) : r4.yz;
    r4.yz = r8.xx ? float2(0,-1) : r4.yz;
    r4.yz = r6.ww ? float2(1,-1) : r4.yz;
    r4.yz = r6.zz ? float2(1,0) : r4.yz;
    r4.yz = r6.yy ? float2(1,1) : r4.yz;
    r4.yz = r6.xx ? float2(0,1) : r4.yz;
    r4.yz = r3.ww ? r4.yz : float2(0,0);
    r5.y = dot(-r4.yz, -r4.yz);
    r5.y = rsqrt(r5.y);
    r4.yz = r5.yy * -r4.yz;
    r4.y = dot(r4.yz, v1.xz);
    r4.z = (int)r4.x;
    r4.z = totalTime * r4.z;
    r5.yz = float2(0.100000001,0.200000003) * r4.zz;
    r4.y = r4.y * 9.99999975e-06 + r5.y;
    r4.y = r4.w * 0.800000012 + r4.y;
    r4.y = sin(r4.y);
    r4.y = 1 + -abs(r4.y);
    r4.x = cmp(1 < (int)r4.x);
    r4.z = r4.w * 0.600000024 + r5.z;
    r4.z = sin(r4.z);
    r4.z = min(0.930000007, abs(r4.z));
    r4.z = r4.x ? r4.z : 0;
    r4.y = r3.w ? r4.y : r4.z;
    r3.w = cmp((int)r3.w == 0);
    r3.w = r4.x ? r3.w : 0;
    r4.x = log2(r4.y);
    r4.x = 14 * r4.x;
    r4.x = exp2(r4.x);
    r0.xyz = -r0.xyz * r2.xxx + float3(0.483999997,0.50999999,0.50999999);
    r0.xyz = r4.xxx * r0.xyz + r2.yzw;
    r4.xyz = r4.xxx * r2.yzw + r2.yzw;
    r0.xyz = r3.www ? r0.xyz : r4.xyz;
    r3.xyz = isGreatSeaMapRender ? r0.xyz : r2.yzw;
  }
  r0.x = texFarTerrain.SampleLevel(PA_LINEAR_CLAMP_FILTER_s, r1.xz, 0).x;
  r0.x = saturate(0.0399999991 * r0.x);
  r0.x = g_isUseHeight ? r0.x : 0;
  r2.xyz = vecHorizon0ColorConst.xyz * r0.xxx;
  r2.xyz = saturate(r2.xyz * float3(0.200000003,0.200000003,0.200000003) + vecHorizon1ColorConst.xyz);
  r4.xyz = float3(1.25,1.25,1.25) * r2.xyz;
  r0.y = texOceanRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r7.xy, 0).w;
  r0.yw = float2(255,9.99999975e-06) * r0.yw;
  r0.y = (int)r0.y;
  r0.z = selectOceanSiegeKey + (int)-r0.y;
  r0.z = max((int)r0.z, (int)-r0.z);
  r0.z = (int)r0.z;
  r0.z = cmp(r0.z < 1);
  r0.z = r0.z ? 1.20000005 : 0.600000024;
  r1.xz = cmp(selectOceanSiegeKey != int2(255,255));
  r1.z = r1.z ? 0.600000024 : 1;
  r0.z = r1.x ? r0.z : r1.z;
  r6.xyzw = float4(-200,0,200,0) + v1.xzxz;
  r6.xyzw = r6.xyzw * float4(7.81249983e-05,7.81249983e-05,7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zwzw;
  r6.xyzw = r6.xyzw + r1.yyyy;
  r6.xyzw = r6.xyzw / fixedTexCoord.xyxy;
  r7.x = texOceanRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r6.xy, 0).w;
  r7.y = texOceanRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r6.zw, 0).w;
  r6.xyzw = float4(0,-200,0,200) + v1.xzxz;
  r6.xyzw = r6.xyzw * float4(7.81249983e-05,7.81249983e-05,7.81249983e-05,7.81249983e-05) + -fixedTexCoord.zwzw;
  r6.xyzw = r6.xyzw + r1.yyyy;
  r6.xyzw = r6.xyzw / fixedTexCoord.xyxy;
  r7.z = texOceanRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r6.xy, 0).w;
  r7.w = texOceanRegionLayer.SampleLevel(PA_POINT_WRAP_FILTER_s, r6.zw, 0).w;
  r6.xyzw = float4(255,255,255,255) * r7.xyzw;
  r1.x = cmp((int)r0.y == 255);
  r6.xyzw = (int4)r6.xyzw;
  r7.xyzw = cmp((int4)r6.xyzw != int4(255,255,255,255));
  r1.y = (int)r7.y | (int)r7.x;
  r1.y = (int)r7.z | (int)r1.y;
  r1.y = (int)r7.w | (int)r1.y;
  r7.xyzw = (int4)r1.yyyy & int4(0x3f800000,0x3f79f9fa,0x3f0c8c8d,0x3f800000);
  r6.xyzw = cmp((int4)r6.xyzw != (int4)r0.yyyy);
  r0.y = (int)r6.y | (int)r6.x;
  r0.y = (int)r6.z | (int)r0.y;
  r0.y = (int)r6.w | (int)r0.y;
  r6.xyz = r0.yyy ? float3(1,0.97647059,0.549019635) : vecTerritoryColor[1].xyz;
  r6.w = r0.y ? 1 : 0.150000006;
  r6.xyzw = r1.xxxx ? r7.xyzw : r6.xyzw;
  r0.y = r6.w * r0.z;
  r1.xyz = r6.xyz * r0.zzz + -r3.xyz;
  r1.xyz = r0.yyy * r1.xyz + r3.xyz;
  r1.xyz = isOceanSiege ? r1.xyz : r3.xyz;
  r0.y = r1.w * 0.100000001 + r5.x;
  r1.xyz = -r2.xyz * float3(1.25,1.25,1.25) + r1.xyz;
  r1.xyz = r0.yyy * r1.xyz + r4.xyz;
  r0.y = -50000 + fViewDistance;
  r0.y = 2.49999994e-06 * r0.y;
  r0.y = max(0.300000012, r0.y);
  r2.xyz = -vecCameraLookAt.xyz + v1.xyz;
  r0.z = dot(r2.xyz, r2.xyz);
  r0.z = sqrt(r0.z);
  r0.y = 700000 * r0.y;
  r0.y = r0.z / r0.y;
  r0.y = min(1, r0.y);
  r0.y = -r0.y * r0.y + 1;
  r0.zw = r0.yw * r0.yw;
  o0.w = saturate(r0.z * r0.x + r0.y);
  r0.xyz = r1.xyz;
  r0.w = r0.w * 0.75 + 0.200000003;
  r0.w = min(1, r0.w);
  r1.xyz = vecHorizon1ColorConst.xyz + -r0.xyz;
  r1.xyz = r0.www * r1.xyz + r0.xyz;
  o0.xyz = isTownMode ? r1.xyz : r0.xyz;
  return;
}